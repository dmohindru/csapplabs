-------------PHASE 1------------------------
Call Address    : 400e3a
Start Address   : 400ee0
Paramater 1     : %rdi
Paramater 2     : %esi
Phase 1 String  : 0x402400
Possible code for phase 1
phase_1(char *input_str)
{
  char *phase1_str = 0x0x402400
  if(strings_not_equal(input_str, phase1_str))
  {
    explode_bomb();
    return;
  }
  printf("Phase 1 defused. How about the next one?\n")
}
-------------------------------------------
-------------PHASE 2------------------------
Call Address    : 400e56
Start Address   : 400efc
Paramater 1     : %rdi (input string)
read_six_numbers reading six integer numbers and store at address
%rsp      = number 1
%rsp + 4  = number 2
%rsp + 8  = number 3
%rsp + 12 = number 4
%rsp + 16 = number 5
%rsp + 20 = number 6
%rsp + 24 = As end condition
Possible numbers at address
%rsp      = 1
for %rsp + 4
%rbx = %rsp + 4
let a = (%rbx)
%eax = a - 4
%eax = %eax + %eax = a - 4 + a - 4 = 2a - 8
a = 2a - 8 (equation for number to be correct)
solving for a
1a - 8 = 0
a = 8
so possibly number is
1 2 4 8 16 32
i_next = (i_prev) * 2
 
-------------------------------------------
-------------PHASE 3------------------------
Call Address    : 400e72
Start Address   : 400f43
Paramater 1     : %rdi (input string)
here we call sscanf function with
1st parameter %rdi: input string by user
2nd parameter %rsi: memory address 0x4025cf which probably contains pointer to format string
3rd parameter %rdx: which is a pointer to memory location %rsp+8
4th parameter %rcx: which is a pointer to memory location %rsp+12
so basically this sscanf is try to read two integer (signed or unsigned) (4 bytes)
and store these number at memory location %rsp+8, %rsp+12
number combos
0   207
1   311
2   707
3   256
4   389
5   206
6   682
7   327
--------------------------------------------
-------------PHASE 4------------------------
Call Address    : 400e8e
Start Address   : 40100c
Paramater 1     : %rdi (input string)
This phase read two integers 
first integer as unsigned should less than or equal to 14
second integer value unknown and type(unsigned or signed)
func4 is called as func4(first_inteter, 0, 14)
return value of func4 should be zero and second_integer should be zero, else bomb explodes
Possible code for func4
int func4(first_arg, second_arg, third_arg)
{
//first_arg in %rdi
//second_arg in %rsi
//third_arg in %rdx
  int ret_val = third_arg;
  ret_val -= second_arg;
  int new_val = ret_val;
  new_val = new_val >> 31;
  ret_val += new_val;
  ret_val = ret_val >> 1;
  new_val = ret_val + (second_arg * 1);
  if(new_val>second_arg)
  {
    third_arg = new_val - 1;
    int new_ret_val = func4(first_arg, second_arg, third_arg)
    return new_ret_val * 2;
    
  }
  else
  {
    ret_val = 0;
    if(new_val<second_arg)
    {
      return ret_val;
    }
    else
    {
      second_arg = new_val + 1;
      int new_ret_val = func4(first_arg, second_arg, third_arg);
      return  (2 * new_ret_val)  + 1;
    }
  }
}
Solution to this phase
0 0
1 0
3 0
7 0
as function func4 return 0 for following value of first_arg
0, 1, 3, 7
--------------------------------------------
-------------PHASE 5------------------------
Call Address    : 400eaa
Start Address   : 401062
Paramater 1     : %rdi (input string)
First check this phase does is to check if string length is 6
--------------------------------------------
